package main

import (
	"fmt"
	"io/ioutil"
	"math/rand"
)

type Chip8 struct { 
	// All data of the CHIP8 Emulator

	memory [4096]byte // 4096 bytes of pure Memory

	//0x0 - 0x1FF Chip8 Interpreter
	//0x050-0x0A0 Fonts
	//0x200-0xFFF Program and RAM

	opcode uint          // Place for the opcode
	V      [16]byte      // CPU registers
	I      uint          // Index register
	pc     uint          // Program Counter
	gfx    [64 * 32]byte // Graphics at a staggering 64x32 pixels

	delayTimer uint
	soundTimer uint

	stack        [16]uint
	stackpointer uint

	key [16]bool // Keys

	drawFlag bool
}

func (chip8 *Chip8) emuInit() {
	//Clears all variables
	chip8.pc = 0x200
	chip8.opcode = 0
	chip8.I = 0
	chip8.stackpointer = 0

	// Clear GFX
	for i := range chip8.gfx {
		chip8.gfx[i] = 0
	}

	// Clear Stack
	for i := range chip8.stack {
		chip8.stack[i] = 0
	}

	// Clear registers V0-VF
	for i := range chip8.V {
		chip8.V[i] = 0
	}

	// Clear Memory
	for i := range chip8.memory {
		chip8.memory[i] = 0
	}

	fmt.Println("Cleared all variables!")

	// Load Fontset
	for i, b := range rca1802 {
		chip8.memory[i] = b
	}

	fmt.Println("Loaded font!")

	// Load Game
	game, err := ioutil.ReadFile("TETRIS")
	if err != nil {
		fmt.Println("Loading game failed!")
		panic(err)
	}

	for i, b := range game {
		chip8.memory[512 + i] = b
	}

	fmt.Println("Loaded game!")
}

func (chip8 *Chip8) emuCycle() {
	chip8.opcode = uint(chip8.memory[chip8.pc]) << 8 | uint(chip8.memory[chip8.pc + 1]) // Get next opcode

	fmt.Println(chip8.opcode)

	// Different variables used by operators to clean the code
	// See: http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#0.0

	//a := chip8.opcode & 0x0FFF
	//b := chip8.opcode & 0x00FF
	NNN := chip8.opcode & 0x0FFF
	KK := byte(chip8.opcode & 0x00FF)
	X := byte(chip8.opcode >> 8 & 0x000F)
	Y := byte(chip8.opcode >> 4 & 0x000F)

	// Decode opcode, pc += 2 -> next cycle, pc += 4 -> skip cycle
	switch chip8.opcode & 0xF000 {

	case 0x0000:
		switch chip8.opcode & 0x000F {
		case 0x0000: // 0x00E0: Clears the screen
			// Clear GFX
			for i := range chip8.gfx {
				chip8.gfx[i] = 0
			}
			chip8.pc += 2
			break

		case 0x000E: // 0x00EE: Returns from subroutine
			chip8.pc = uint(chip8.memory[chip8.stackpointer]) << 8 | uint(chip8.memory[chip8.stackpointer + 1])
			// chip8.stackpointer -= 1 // I think that's not needed? This function seems to be broken either way
			// chip8.pc += 2 // Might be wrong here <- Possibly fixed a big by deleting it? We'll see
			break
		}
		break
	case 0x1000: // 1NNN: Jump to location nnn.
		chip8.pc = NNN
		break
	case 0x2000: // 2NNN: Calls subroutine at adress NNN, thanks to "massung" for showing me how to correctly implement that.
		chip8.memory[chip8.stackpointer] = byte(chip8.pc >> 8 / 0x00FF)
		chip8.memory[chip8.stackpointer + 1] = byte(chip8.pc & 0x00FF)

		chip8.pc = NNN
		break
	case 0x3000: // 3XKK Skip next instruction if Vx = kk.
		if chip8.V[X] == KK {
			chip8.pc += 4
		} else {
			chip8.pc += 2
		}
		break
	case 0x4000: // 4XKK Skip next instruction if NOT Vx = kk.
		if chip8.V[X] != KK {
			chip8.pc += 4
		} else {
			chip8.pc += 2
		}
		break
	case 0x5000: // 5xy0: Skip next instruction if Vx = Vy.
		if chip8.V[X] == chip8.V[Y] {
			chip8.pc += 4
		} else {
			chip8.pc += 2
		}
		break
	case 0x6000: // 6xkk: Set Vx = kk
		chip8.V[X] = KK
		chip8.pc += 2
		break
	case 0x7000: // 7xkk: Vx = Vx + kk.
		chip8.V[X] += KK
		chip8.pc += 2
		break
	case 0x8000:
		switch chip8.opcode & 0x000F {
		case 0x0000: // 8XY0: Set Vx = Vy.
			chip8.V[X] = chip8.V[Y]
			chip8.pc += 2
			break
		case 0x0001: // 8XY1: set Vx = Vx OR Vy.
			chip8.V[X] = chip8.V[X] | chip8.V[Y]
			chip8.pc += 2
			break
		case 0x0002: // 8XY2: Set Vx = Vx AND Vy. WARNING: This implementation is wrong!
			chip8.V[X] = chip8.V[X] & chip8.V[Y]
			chip8.pc += 2
			break
		case 0x0003: // 8XY3: Set Vx = Vx XOR Vy.
			chip8.V[X] = chip8.V[X] ^ chip8.V[Y]
			chip8.pc += 2
			break
		case 0x0004: // 8XY4: Set Vx = Vx + Vy, set VF = carry.
			// TODO: Implement
			break
		case 0x0005: // 8XY5: Set Vx = Vx - Vy, set VF = NOT borrow.
			// Is this correct, why did I implement it like that?
			if chip8.V[X] > chip8.V[Y] {
				chip8.V[0xF] = 1
			} else {
				chip8.V[0xF] = 0
			}
			chip8.V[X] -= chip8.V[Y]
			chip8.pc += 2
			break
		case 0x0006: // 8XY6: Set Vx = Vx SHR 1.
			break
		case 0x0007: // 8XY7: Set Vx = Vy - Vx, set VF = NOT borrow.
			if chip8.V[Y] > chip8.V[X] {
				chip8.V[0xF] = 1
			} else {
				chip8.V[0xF] = 0
			}
			chip8.V[X] = chip8.V[Y] - chip8.V[X]
			chip8.pc += 2
			break
		case 0x000E: // 8XY8: Set Vx = Vx SHL 1.
			// TO:DO: Implement
			break
		}
		break
	case 0x9000: // 9XY0: Skip next instruction if Vx != Vy.
		if chip8.V[X] != chip8.V[Y] {
			chip8.pc += 2 // Add 2 so we skip
		}
		chip8.pc += 2
		break
	case 0xA000: // ANNN: Sets I to the adress NNN
		chip8.I = NNN
		chip8.pc += 2
		break
	case 0xB000: // BNNN: Jump to location nnn + V0
		chip8.pc = NNN + uint(chip8.V[0x0])
		break // Don't go to the next instruction since we jump to a location
	case 0xC000: // Cxkk: Set Vx = random byte AND kk.
		chip8.V[X] = byte(rand.Intn(255)) & KK
		chip8.pc += 2
		break // TODO: Implement
	case 0xD000: // Dxyn: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.
		break
	case 0xE000:
		switch chip8.opcode & 0x000F {
		case 0x000E: // Ex9E: Skip next instruction if key with the value of Vx is pressed
			break
		case 0x0001: // ExA1: Skip next instruction if key with the value of Vx is not pressed.
			break
		}
		break
	case 0xF000:
		switch chip8.opcode & 0x00FF {
		case 0x0007: // FX07: Set Vx = delay timer value.
			chip8.V[X] = byte(chip8.delayTimer)
			chip8.pc += 2
			break
		case 0x000A: // FX0A: Wait for a key press, store the value of the key in Vx.
			break // TODO
		case 0x0015: // FX15: Set delay timer = Vx.
			chip8.delayTimer = uint(chip8.V[X])
			chip8.pc += 2
		case 0x0018: // FX18: Set sound timer = Vx.
			chip8.soundTimer = uint(chip8.V[X])
			chip8.pc += 2
		case 0x001E: // FX1E: Set I = I + Vx.
			chip8.I += uint(chip8.V[X])
			chip8.pc += 2
		case 0x0029: // FX29: Set I = location of sprite for digit Vx.
			break // TODO
		case 0x0033: // FX33: Store BCD representation of Vx in memory locations I, I+1, and I+2.
			break // TODO
		case 0x0055: // FX55: Store registers V0 through Vx in memory starting at location I.
			for val := byte(0); val != X; val++ {
				chip8.memory[chip8.I + uint(val)] = chip8.V[val]
			}
			chip8.pc += 2
			break
		case 0x0065: // FX65: Read registers V0 through Vx from memory starting at location I.
			for val := byte(0); val != X; val++ {
				chip8.V[val] = chip8.memory[chip8.I + uint(val)]
			}
			chip8.pc += 2
			break
		}
		break
	default:
		fmt.Printf("Unimplemented Opcode 0x%X", chip8.opcode)
		panic(chip8.opcode)
	}

	//Updates Timers
	if chip8.delayTimer > 0 {
		chip8.delayTimer--
	}

	if chip8.soundTimer > 0 {
		if chip8.soundTimer == 1 {
			fmt.Println("Imagine that this is beeping right now!")
			chip8.soundTimer--
		}
	}
}

func (chip8 *Chip8) opcodeHandling() {

}

func (chip8 *Chip8) setKeys() {
	// Check for newly pressed keys
}

func main() {

	// Graphics
	// Input

	var emu Chip8
	emu.emuInit()

	for i := 0; i != 15; i++{ // Limit execution in test phase
		emu.emuCycle()

		if emu.drawFlag {
			//Graphics should be drawn
		}

		emu.setKeys() // Check for new keypresses by the user
	}
}

// rca_1802 ROM for the CHIP-8 virtual machine.
// Shamelessly stolen from: https://github.com/massung/CHIP-8/blob/4a496ca1e99cf4f288a33e26e58c953828d35c86/chip8/rom.go
var rca1802 = [0x200]byte{
	0xF0, 0x90, 0x90, 0x90, 0xF0, 0x20, 0x60, 0x20,
	0x20, 0x70, 0xF0, 0x10, 0xF0, 0x80, 0xF0, 0xF0,
	0x10, 0xF0, 0x10, 0xF0, 0xA0, 0xA0, 0xF0, 0x20,
	0x20, 0xF0, 0x80, 0xF0, 0x10, 0xF0, 0xF0, 0x80,
	0xF0, 0x90, 0xF0, 0xF0, 0x10, 0x20, 0x40, 0x40,
	0xF0, 0x90, 0xF0, 0x90, 0xF0, 0xF0, 0x90, 0xF0,
	0x10, 0xF0, 0xF0, 0x90, 0xF0, 0x90, 0x90, 0xE0,
	0x90, 0xE0, 0x90, 0xE0, 0xF0, 0x80, 0x80, 0x80,
	0xF0, 0xE0, 0x90, 0x90, 0x90, 0xE0, 0xF0, 0x80,
	0xF0, 0x80, 0xF0, 0xF0, 0x80, 0xF0, 0x80, 0x80,
	0x3C, 0x7E, 0xE7, 0xC3, 0xC3, 0xC3, 0xC3, 0xE7,
	0x7E, 0x3C, 0x18, 0x38, 0x58, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x3C, 0x3E, 0x7F, 0xC3, 0x06,
	0x0C, 0x18, 0x30, 0x60, 0xFF, 0xFF, 0x3C, 0x7E,
	0xC3, 0x03, 0x0E, 0x0E, 0x03, 0xC3, 0x7E, 0x3C,
	0x06, 0x0E, 0x1E, 0x36, 0x66, 0xC6, 0xFF, 0xFF,
	0x06, 0x06, 0xFF, 0xFF, 0xC0, 0xC0, 0xFC, 0xFE,
	0x03, 0xC3, 0x7E, 0x3C, 0x3E, 0x7C, 0xC0, 0xC0,
	0xFC, 0xFE, 0xC3, 0xC3, 0x7E, 0x3C, 0xFF, 0xFF,
	0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60,
	0x3C, 0x7E, 0xC3, 0xC3, 0x7E, 0x7E, 0xC3, 0xC3,
	0x7E, 0x3C, 0x3C, 0x7E, 0xC3, 0xC3, 0x7F, 0x3F,
	0x03, 0x03, 0x3E, 0x7C, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x63, 0x02, 0x35, 0x00, 0x11, 0x24,
	0xF3, 0x29, 0x21, 0x70, 0x80, 0x40, 0x80, 0x06,
	0x80, 0x06, 0x80, 0x06, 0x80, 0x06, 0xF0, 0x29,
	0x21, 0x70, 0xF4, 0x29, 0x21, 0x70, 0xA1, 0x76,
	0x21, 0x70, 0x75, 0xFF, 0x21, 0x66, 0x87, 0x80,
	0x87, 0x0E, 0x87, 0x0E, 0x87, 0x0E, 0x87, 0x0E,
	0x21, 0x66, 0x88, 0x74, 0xA0, 0x00, 0xF4, 0x1E,
	0x80, 0x30, 0x61, 0x80, 0xF1, 0x1E, 0xF1, 0x1E,
	0x70, 0xFF, 0x30, 0x00, 0x11, 0x3C, 0x80, 0x80,
	0xF0, 0x55, 0x74, 0x01, 0x44, 0x00, 0x73, 0x01,
	0x43, 0x10, 0x12, 0x00, 0x35, 0x27, 0x11, 0x04,
	0x65, 0x00, 0x46, 0x18, 0x11, 0x62, 0x76, 0x06,
	0x11, 0x04, 0x00, 0x00, 0x11, 0x04, 0xA1, 0x7A,
	0xD5, 0x66, 0xF8, 0x0A, 0xD5, 0x66, 0xF8, 0x29,
	0xD5, 0x65, 0x75, 0x05, 0x00, 0xEE, 0x00, 0x40,
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}
